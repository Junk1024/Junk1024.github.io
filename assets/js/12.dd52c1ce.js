(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{414:function(t,s,a){"use strict";a.r(s);var e=a(3),n=Object(e.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("为什么要编写这个教程？因为我在学习 Git 的过程中，在网上找了一堆 Git 相关的文章和教程，感觉都有点差强人意，那就自己写一个自己能看的懂的记录下来，方便以后自己在使用过程出现遗忘问题时能快速找到解决方案。\n首先，本教程绝对面向初学者，没有接触过版本控制概念的读者也可以轻松入门，不必担心起步难度，因为我就是初学者！\n其次，本教程出自一个初学者，难免会有不恰当的地方，如果您有幸看到我的这篇文章并发现了问题，欢迎您留言指出。")]),t._v(" "),s("h2",{attrs:{id:"git-简介"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#git-简介"}},[t._v("#")]),t._v(" Git 简介")]),t._v(" "),s("p",[t._v("Git 是什么？Git 是目前世界上最先进的分布式版本控制系统。")]),t._v(" "),s("p",[t._v("说到这里就不得不提分布式版本控制系统。先说集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。")]),t._v(" "),s("p",[t._v("那分布式版本控制系统与集中式版本控制系统有何不同呢？首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整\n的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如\n何协作呢？比方说你在自己电脑上改了文件 A，你的同事也在他的电脑上改了文件 A，这时，你们俩之间只需把各自的修改推送给对方，就\n可以互相看到对方的修改了。")]),t._v(" "),s("p",[t._v("和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，\n随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。当然，Git 的优势不单是\n不必联网这么简单，后面我们还会看到 Git 极其强大的分支管理。")]),t._v(" "),s("h2",{attrs:{id:"git-安装"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#git-安装"}},[t._v("#")]),t._v(" Git 安装")]),t._v(" "),s("p",[t._v("安装直接到"),s("a",{attrs:{href:"https://git-scm.com/downloads",target:"_blank",rel:"noopener noreferrer"}},[t._v("官网"),s("OutboundLink")],1),t._v("下载对应的版本就行。基本不会有什么问题，这篇文章着重于使用和理解。也可以\n参考这个"),s("a",{attrs:{href:"https://www.runoob.com/git/git-install-setup.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("教程"),s("OutboundLink")],1),t._v("windows 安装完成之后在任一目录下右键查看是否有 Git\nBash Here，若有则证明安装成功，以后的命令都可以在 Git Bash Here 里面运行。")]),t._v(" "),s("h2",{attrs:{id:"版本库"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#版本库"}},[t._v("#")]),t._v(" 版本库")]),t._v(" "),s("p",[t._v("什么是版本库呢？版本库又名仓库，英文名 repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被 Git 管理起来，每\n个文件的修改、删除，Git 都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。\n首先你要学会创建一个本地仓库，你可以在命令行新建一个文件夹(learngit)，然后进入进行管理。")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("mkdir learngit\ncd learngit\ngit init\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("p",[t._v("git init 命令把这个目录变成 Git 可以管理的仓库。瞬间 Git 就把仓库建好了，而且告诉你是一个空的仓库（empty repository）\n，然后你可以发现当前目录下多了一个.git 的目录，这个目录是 Git 来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，\n不然改乱了，就把 Git 仓库给破坏了。")]),t._v(" "),s("p",[t._v("接下来你需要明白工作区、暂存区、版本库。工作区就是你创建的目录里面所能看到的(不包括.git)，暂存区和版本库相对来说是不可见\n的，这个说法只是便于理解，其实他们在自动生成的.git 文件夹里面会有相应的操作记录。")]),t._v(" "),s("h3",{attrs:{id:"文件的添加和删除"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#文件的添加和删除"}},[t._v("#")]),t._v(" 文件的添加和删除")]),t._v(" "),s("p",[t._v("刚开始仓库是空的，然后你在工作区写了一个 a.txt 文件，此时这个文件只存在于你的工作区，那么如何将它添加到你的版本库里面呢？首\n先需要将 a.txt 文件添加到缓存区,然后提交到版本库")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("git add a.txt\ngit commit -m '添加了a.txt文件'\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br")])]),s("p",[t._v("其中 add 后可跟目录名和文件名，如果要添加工作区的所有文件，也可以添加工作区的所有文件，对应代码如下")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("git add 目录名\ngit add 文件名\ngit add .\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("p",[t._v("当然也可以一次添加多个指定的文件，用空格隔开就行。删除文件同理，只需将 add 替换为 rm 即可。对于工作区的文件，如果不确定其状\n态，可以通过下面代码来查看其状态")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("git status\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("然后我们分析一下各种情况。当你刚执行完 commit 操作，暂存区是空的时，输入命令会提示你 working tree clean；当你修改了工作区\n的文件之后再使用 status 命令则会显示文件已修改，并提醒你提交到版本库；当你新增了文件的时候，会提醒你工作区有未追踪的文件，\n然后提醒你将新文件提交到版本库；当你删除了文件，会提醒你工作区有文件被删除，并提示你更新到版本库。")]),t._v(" "),s("h3",{attrs:{id:"错误修改的补救"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#错误修改的补救"}},[t._v("#")]),t._v(" 错误修改的补救")]),t._v(" "),s("p",[t._v("当然我们不可避免的会有错误的修改，当我们对 a.txt 文件进行了一次错误的修改，怎么撤回修改呢，具体情况有以下三种：")]),t._v(" "),s("p",[t._v("① 只在工作区做了修改，还未添加至缓存区，此时可以使用下面这个命令将工作区回到最近一次 add 或者 commit 的状态。(工作区误删恢复也可\n以用这个命令)")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("git checkout -- a.txt\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("② 你做了错误的修改并且已经提交到了缓存区，需要先撤销暂存区的修改，然后就回到了第一种情况。")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("git reset HEAD a.txt\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("③ 如果你已经进行了 commit 提交，那么你只需回退到上一个版本库即可，版本回退下面会细讲。")]),t._v(" "),s("h3",{attrs:{id:"版本管理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#版本管理"}},[t._v("#")]),t._v(" 版本管理")]),t._v(" "),s("p",[t._v("对版本库的历史版本管理，使用以下命令查看提交记录。然后会由近到远以此显示你的提交记录，然后通过给出的 commit id 回到指定版\n本，当然也有另一种指令，快捷的回退到前 n 个版本，其中 n 与^的数量相对应。")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("git log\ngit reset --hard  57aa6817806ad984484\n//回退到commit id 为57aa6817806ad984484的版本\ngit reset --hard HEAD^\n//回退到上一个版本\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br")])]),s("p",[t._v("然后你的工作区和版本库就会是你想要的版本。commit id 不用写全只要写到唯一位就行。如果觉得 git log 显示的信息太繁琐，可以加\n上参数 --pretty=oneline 只会显示版本号和提交时的备注信息，这样阅读起来更友好得多。这时又有一个问题，假设你有按顺序的三个版\n本 a，b，c，你从 c 版本回到了 b 版本，你在使用 git log 命令会不显示你的 c 版本的 commit，这是你如果想要再次回到 c 版本，\n应该怎么做呢？这是需要用到下面这个命令，就可以看到 commit id 了，然后再执行回退命令就可以了。")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("git reflog\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("这里我们就能看出两者的区别，查过资料得到证实，git log 命令可以显示当前分支所有提交过的版本信息，不包括已经被删除的 commit\n记录和 reset 的操作。(注意: 只是当前分支操作的信息)。git reflog 命令可以查看所有分支的所有操作记录信息（包括已经被删除的\ncommit 记录和 reset 的操作）。")]),t._v(" "),s("p",[t._v("总结一下:\nGit 允许我们在版本的历史之间穿梭，使用命令 git reset --hard commit_id。\n穿梭前，用 git log 可以查看提交历史，以便确定要回退到哪个版本。\n要重返未来，用 git reflog 查看命令历史，以便确定要回到未来的哪个版本。")]),t._v(" "),s("h2",{attrs:{id:"分支"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分支"}},[t._v("#")]),t._v(" 分支")]),t._v(" "),s("p",[t._v("分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习前端的时候，另一个你正在另一个平行宇宙里努力学习后端。\n如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你就成了全栈工程师。\n分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了 50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。\n现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。")]),t._v(" "),s("p",[t._v("在版本回退里，我们已经知道，每次提交，Git 都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在 Git\n里，这个分支叫主分支，即 master 分支(从 2020 年 10 月 1 日开始，Github 将所有“master 分支”一律改名为“main 分支”，注意识别)。HEAD 严\n格来说不是指向提交，而是指向 master，master 才是指向提交的，所以，HEAD 指向的就是当前分支。")]),t._v(" "),s("p",[t._v("一开始的时候，master 分支是一条线，Git 用 master 指向最新的提交，再用 HEAD 指向 master，就能确定当前分支，以及当前分支的提交点。\n每次提交，master 分支都会向前移动一步，这样，随着你不断提交，master 分支的线也越来越长。当我们创建新的分支，例如 dev 时，Git 新\n建了一个指针叫 dev，指向 master 相同的提交，再把 HEAD 指向 dev，就表示当前分支在 dev 上。Git 创建一个分支很快，因为除了增加一个 dev\n指针，改改 HEAD 的指向，工作区的文件都没有任何变化！不过，从现在开始，对工作区的修改和提交就是针对 dev 分支了，比如新提交一次\n后，dev 指针往前移动一步，而 master 指针不变。")]),t._v(" "),s("p",[t._v("假如我们在 dev 上的工作完成了，就可以把 dev 合并到 master 上。合并完分支后，甚至可以删除 dev 分支。删除 dev 分支就是把 dev 指针给删\n掉，删掉后，我们就剩下了一条 master 分支。")]),t._v(" "),s("h3",{attrs:{id:"分支的创建、切换与合并"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分支的创建、切换与合并"}},[t._v("#")]),t._v(" 分支的创建、切换与合并")]),t._v(" "),s("p",[t._v("首先，我们创建 dev 分支，然后切换到 dev 分支，其实这个代码相当于两行代码，先创建再切换分支。其中，git checkout 命令我们在前面\n的恢复文件时也用到了，为了作区分，建议使用 switch 进行分支的切换。")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("git checkout -b dev\ngit switch -c dev\n//等同于下面两行代码\ngit branch dev\ngit checkout dev\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br")])]),s("p",[t._v("然后，用 git branch 命令查看分支")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("git branch\n//当前分支前面会有一个*\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br")])]),s("p",[t._v("切换到 dev 分支以后我们就可以在 dev 分支上正常提交，等到提交之后，再回到 master 合并 dev，然后就可以删掉 dev 分支了。")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("git merge dev\n//在master分支上合并dev\ngit branch -d dev\n//删除dev分支\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("h3",{attrs:{id:"合并冲突的解决"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#合并冲突的解决"}},[t._v("#")]),t._v(" 合并冲突的解决")]),t._v(" "),s("p",[t._v("当 Git 无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。解决冲突就是把 Git 合并失败的文件手动编辑为我们希望的内容，再提交。")]),t._v(" "),s("h3",{attrs:{id:"恢复误删的分支"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#恢复误删的分支"}},[t._v("#")]),t._v(" 恢复误删的分支")]),t._v(" "),s("p",[t._v("如果你在分支上做了提交并且没有合并到主分支上就被你删了，可以先找到 commit id，然后恢复误删的分支。")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("git log -g\n//找到误删分支上的commit id\ngit branch newbranch commit id\n//恢复分支\ngit switch newbranch\n//切换到恢复的分支\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br")])]),s("h2",{attrs:{id:"远程仓库"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#远程仓库"}},[t._v("#")]),t._v(" 远程仓库")]),t._v(" "),s("p",[t._v("下载完 Git，安装教程里面有配置的教程，配置完成之后可以通过命令查看绑定的远程仓库，可以删除绑定，添加绑定。")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("git remote -v\n//查看绑定的远程仓库信息，没有绑定就是空白，有绑定会显示名字\ngit remote add origin 仓库地址\n//绑定远程仓库\ngit remote rm origin\n//删除绑定的远程仓库，origin为远程仓库名，远程仓库名在本地的名称默认都为origin\ngit clone 仓库地址\n//从远程仓库克隆项目\ngit push origin master\n//将本地master分支推向远程仓库，注意Github现在将默认分支master改为了main\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br")])]),s("p",[t._v("当远程仓库有多个分支，克隆制定分支到本地")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("git clone -b 分支名 仓库地址\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])])])}),[],!1,null,null,null);s.default=n.exports}}]);